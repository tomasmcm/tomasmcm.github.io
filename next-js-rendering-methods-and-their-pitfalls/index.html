<!DOCTYPE html> <html lang="en"> <head> <title>TMCM / Next.js Rendering Methods and their Pitfalls</title> <meta name="author" content="TMCM"> <meta name="description" content="In a recent project, we learned about Next.js’ data rendering methods the hard way — through slow page loads, routing nightmares, and revalidation migraines. After battling through the pitfalls of SSR, SSG, ISR and ODR, we devised a custom solution that gave us the best of all: pre-rendered HTML, fast page loads, dynamic data, no backend changes. In this post,..."> <meta name="keywords" content="Frontend, Next.js, SSR, SSG, ISR, ODR"> <meta property="og:title" content="TMCM / Next.js Rendering Methods and their Pitfalls"> <meta property="og:description" content="In a recent project, we learned about Next.js’ data rendering methods the hard way — through slow page loads, routing nightmares, and revalidation migraines. After battling through the pitfalls of SSR, SSG, ISR and ODR, we devised a custom solution that gave us the best of all: pre-rendered HTML, fast page loads, dynamic data, no backend changes. In this post,..."> <meta property="og:image" content="/assets/images/blog/7d5f1c0b-79bc-44ee-982a-fc83933ceb9a.jpg"> <meta property="og:url" content="/next-js-rendering-methods-and-their-pitfalls/"> <meta name="twitter:card" content="summary_large_image"> <meta property="og:site_name" content="TMCM"> <meta name="twitter:image:alt" content="TMCM"> <meta name="twitter:site" content="@tomasmcm"> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="robots" content="index,follow"> <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"> <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32"> <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16"> <link rel="manifest" href="/manifest.json"> <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"> <meta name="theme-color" content="#ffffff"><link rel="stylesheet" href="/assets/css/style.css?version=1735314396015746070"> <link rel="preload" as="font" href="/assets/fonts/now-regular-webfont.woff2" type="font/woff2" crossorigin="anonymous"> <link rel="preload" as="font" href="/assets/fonts/now-bold-webfont.woff2" type="font/woff2" crossorigin="anonymous"> <link rel="preload" as="font" href="/assets/fonts/now-light-webfont.woff2" type="font/woff2" crossorigin="anonymous"> <link rel="preload" as="font" href="/assets/fonts/now-medium-webfont.woff2" type="font/woff2" crossorigin="anonymous"> <link rel="preload" as="font" href="/assets/fonts/Radnika-Regular.woff2" type="font/woff2" crossorigin="anonymous"> <link rel="preload" as="font" href="/assets/fonts/Radnika-Medium.woff2" type="font/woff2" crossorigin="anonymous"> <link rel="preload" as="font" href="/assets/fonts/Radnika-Light.woff2" type="font/woff2" crossorigin="anonymous"> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-47256452-1"></script> <script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-47256452-1");</script> </head> <body class="body--post"> <main class="main"> <header class="header"> <div class="container"> <h1 class="logo"> <a class="logo__link" href="/"> <span>T</span> <span>M</span> <span>C</span> <span>M</span> </a></h1> </div> </header> <header class="header--post" style="background-image: url('/assets/images/blog/7d5f1c0b-79bc-44ee-982a-fc83933ceb9a.jpg')"></header> <section class="post"> <div class="container"> <article class="article-wrapper"> <h1 class="h1">Next.js Rendering Methods and their Pitfalls</h1> <h5 class="h5 article-meta">Jun 30, 2023 · <span title="Estimated read time"> 4 mins read </span></h5> <p>In a recent project, we learned about Next.js’ data rendering methods the hard way — through slow page loads, routing nightmares, and revalidation migraines. After battling through the pitfalls of SSR, SSG, ISR and ODR, we devised a custom solution that gave us the best of all: pre-rendered HTML, fast page loads, dynamic data, no backend changes. In this post, we share our hard-earned knowledge so you can skip the pain and get to the gain.</p> <p>Next.js offers a couple of ways to handle having content managed separately from the website code (using a CMS):</p> <ul> <li>Server-Side Rendering (SSR)</li> <li>Static Site Generation (SSG)</li> <li>Incremental Static Regeneration (ISR)</li> <li>On-Demand Revalidation (ODR)</li> </ul> <p><strong>Server-Side Rendering</strong> (SSR) is when the Next.js server fetches the content for the page being requested at the moment when someone is visiting the page. This means the page will take longer to display, there will be more load on the CMS server, but people will always see the latest content. (There can be caching mechanisms to help with this).</p> <p><strong>Static Site Generation</strong> (SSG) moves all the content fetching to the build stage. The Next.js server fetches all the content necessary for all the pages, builds the website and stores everything. When someone visits the website the Next.js server simply returns what it stored. This means pages are fast, there isn’t a lot of load on the CMS server (only during builds), but people will see the content as it was the last time the website was built.</p> <p><strong>Incremental Static Regeneration</strong> (ISR) tries to solve the issues of SSG by having an option to refresh the content after the website is built. When it is enabled, the Next.js server still returns what it stored, but in the background it refreshes and updates the content. The downside is only the next person will see the updated content (since the person that triggered the content refresh still sees the outdated content).</p> <p><strong>On-Demand Revalidation</strong> (ODR) improves on ISR by providing an API to trigger content updates. So instead of relying on people visiting the page, we can ping the Next.js server when a piece of content is updated (in the CMS for example). The downside of this approach is that it requires serverless functions (instead of a simple static server) and requires configuring the CMS to trigger those endpoints.</p> <p>Having this understanding of the options, here’s our problem description:</p> <p class="u-pl-8x">We want to update the content of the website, up to once a day, without having to configure a lot of things in the CMS, and we don’t want to rely on visitors, since they might not visit the specific pages that are updated.</p> <p>If at this point you are thinking we just need a cron, you are right. At least half right. Because the second issue is we don’t want to be making unnecessary deployments (for billing reasons), so we need a way to know if the content was updated and only deploy if yes.</p> <p>Our approach turned out to be quite simple, even if getting there was quite complex. Using a cron in Github Actions, we build the website once a day and create a hash with the files where the CMS content is stored: the <code class="language-plaintext highlighter-rouge">.json</code> files inside <code class="language-plaintext highlighter-rouge">.next/server/pages</code> (we need to ignore any <code class="language-plaintext highlighter-rouge">.nft.json</code> files as those are for Node File Tracing). By creating a hash with the file contents we can compare it with the hash from the previous day and only trigger a deployment if they are different. We can store the hash in a file in the <code class="language-plaintext highlighter-rouge">public</code> folder, so that if there is a manual deployment throughout the day, we can still have a hash to compare to.</p> <p>We could optimise this approach by hashing the CMS content directly and skipping the website build, but that requires maintaining a list of all the content being used. The method we ended up with is hopefully zero maintenance as it relies on the same build process that is used to deploy the website.</p> <p>How would you solve this problem? Let us know on twitter <a href="https://twitter.com/Whitesmithco">@whitesmithco</a></p> </article> <div class="post-meta"> <span class="h2">Source</span> <p><a title="Whitesmith.co" href="https://www.whitesmith.co/blog/next-js-rendering-methods-and-their-pitfalls/" target="_blank" rel="noopener">Whitesmith.co</a></p> </div> </div> </section> <section class="post-navigation"> <div class="container"> <a title="Previous The ultimate no-code smart contract workflow" href="/the-ultimate-no-code-smart-contract-workflow/" class="prev"> <span class="h2">Previous</span> <h2 class="h2">The ultimate no-code smart contract workflow</h2> </a> <a title="Next No-code your way to validation" href="/no-code-validation/" class="next"> <span class="h2">Next</span> <h2 class="h2">No-code your way to validation</h2> </a> </div> </section> </main> <footer class="footer"> <div class="container footer__row"> <section class="footer__section"><h2 class="h2">IPFS</h2> <a title="IPFS Version" href="https://tomasmcm.eth.limo/" target="_blank">Decentralised version</a></section> <section class="footer__section"> <h2 class="h2">Follow</h2> <ul> <li><a title="Twitter" href="https://www.linkedin.com/in/tomasmcm/" target="_blank">Linkedin</a></li> <li><a title="Twitter" href="https://twitter.com/tomasmcm" target="_blank">Twitter</a></li> <li><a title="Github" href="https://github.com/tomasmcm" target="_blank">Github</a></li> </ul> </section> <section class="footer__section"> <h2 class="h2">More</h2> <ul> <li><a title="Archive" href="/archive/">Archive</a></li> <li><a title="AI LLMs" href="/llms/">AI LLMs</a></li> <li><a title="Maker" href="/maker/">Maker</a></li> <li><a title="Blog" href="/blog/">Blog</a></li> </ul> </section> </div> </footer> </body> </html>